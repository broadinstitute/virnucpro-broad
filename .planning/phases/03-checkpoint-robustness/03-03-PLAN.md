---
phase: 03-checkpoint-robustness
plan: 03
type: execute
wave: 3
depends_on: ["03-01", "03-02"]
files_modified: [virnucpro/pipeline/prediction.py, tests/test_checkpoint_validation.py, tests/test_checkpoint_compatibility.py]
autonomous: true

must_haves:
  truths:
    - "Pipeline validates checkpoints on load and save"
    - "Resume shows summary of found/missing checkpoints"
    - "Tests verify validation catches corruption"
  artifacts:
    - path: "tests/test_checkpoint_validation.py"
      provides: "Validation test suite"
      min_lines: 100
    - path: "tests/test_checkpoint_compatibility.py"
      provides: "Backward compatibility tests"
      min_lines: 80
  key_links:
    - from: "virnucpro/pipeline/prediction.py"
      to: "checkpoint validation"
      via: "CheckpointManager integration"
      pattern: "validate.*checkpoint"
---

<objective>
Integrate checkpoint robustness into the pipeline with comprehensive testing.

Purpose: Wire validation and versioning into the main pipeline flow with test coverage.
Output: Fully integrated checkpoint robustness with tests verifying all failure modes.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-checkpoint-robustness/03-CONTEXT.md
@.planning/phases/03-checkpoint-robustness/03-01-SUMMARY.md
@.planning/phases/03-checkpoint-robustness/03-02-SUMMARY.md

# Pipeline and checkpoint modules
@virnucpro/pipeline/prediction.py
@virnucpro/core/checkpoint.py
@virnucpro/core/checkpoint_validation.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Integrate validation into pipeline</name>
  <files>virnucpro/pipeline/prediction.py</files>
  <action>
    Wire checkpoint validation and recovery into the main pipeline:

    1. Update checkpoint loading in run_pipeline():
       - Use CheckpointManager's new validation-aware load methods
       - Check skip_checkpoint_validation flag from config
       - On resume, log summary: "Found 15/20 checkpoints, resuming 5 files"

    2. Add checkpoint validation error handling:
       - Catch CheckpointError from validation
       - If force_resume flag set, log warning and continue
       - Otherwise, exit with code 3 (CHECKPOINT_EXIT_CODE)
       - Log detailed error with file path and reason

    3. Update checkpoint saving to use atomic_save:
       - Import atomic_save from checkpoint module
       - Replace any direct torch.save calls
       - Add post-save validation unless skip_validation set

    4. Add resume summary at pipeline start:
       - Count existing valid checkpoints
       - List files to be processed
       - Show any failed checkpoints from failed_checkpoints.txt
       - Example: "Resuming: 15/20 complete, 2 failed, 3 to process"

    Follow the resume logging pattern from CONTEXT.md decisions.
  </action>
  <verify>grep -n "CheckpointError\|atomic_save" virnucpro/pipeline/prediction.py</verify>
  <done>prediction.py integrates validation with proper error handling and logging</done>
</task>

<task type="auto">
  <name>Task 2: Create validation test suite</name>
  <files>tests/test_checkpoint_validation.py</files>
  <action>
    Create comprehensive tests for checkpoint validation:

    1. Test validate_checkpoint() with various corruption types:
       - test_validate_empty_file(): 0-byte file detection
       - test_validate_non_zip_file(): Invalid format detection
       - test_validate_corrupted_torch_file(): Broken pickle detection
       - test_validate_missing_required_keys(): Structure validation
       - test_validate_valid_checkpoint(): Successful validation

    2. Test error type distinction:
       - test_distinguish_corrupted_vs_incompatible()
       - Verify error messages are specific and actionable

    3. Test batch validation:
       - test_validate_checkpoint_batch()
       - Mix of valid and invalid checkpoints
       - Verify all are checked and results returned

    4. Test failed checkpoint logging:
       - test_log_failed_checkpoint()
       - test_load_failed_checkpoints()
       - Verify file format matches specification

    Use pytest fixtures to create test checkpoint files.
    Create actual corrupted files (empty, text, truncated zip).
  </action>
  <verify>pytest tests/test_checkpoint_validation.py -v</verify>
  <done>Validation tests cover all corruption scenarios and error types</done>
</task>

<task type="auto">
  <name>Task 3: Create backward compatibility tests</name>
  <files>tests/test_checkpoint_compatibility.py</files>
  <action>
    Create tests for version management and backward compatibility:

    1. Test version embedding:
       - test_atomic_save_adds_version(): Verify version added to dict
       - test_version_constant_correct(): Check VERSION = "1.0"

    2. Test backward compatibility:
       - test_load_pre_optimization_checkpoint():
         * Create checkpoint without version field
         * Load with load_with_compatibility()
         * Verify treated as version "0.x"
       - test_load_current_version_checkpoint():
         * Create v1.0 checkpoint
         * Verify loads without issue

    3. Test forward compatibility:
       - test_reject_future_version():
         * Create checkpoint with version "2.0"
         * Verify raises error with upgrade message

    4. Test recovery flags:
       - test_skip_validation_flag(): Verify validation can be skipped
       - test_force_resume_flag(): Verify can continue past corrupted files

    Use temporary directories for test checkpoints.
    Mock torch.save/load where appropriate.
  </action>
  <verify>pytest tests/test_checkpoint_compatibility.py -v</verify>
  <done>Compatibility tests verify version handling and backward compatibility</done>
</task>

</tasks>

<verification>
1. Pipeline validates checkpoints during load and save operations
2. Resume logging shows clear summary of checkpoint status
3. Tests verify all corruption types are caught
4. Tests verify backward compatibility with pre-optimization checkpoints
5. Exit code 3 returned for checkpoint-specific failures
</verification>

<success_criteria>
- Pipeline integrates validation with proper error handling
- Resume shows "Found X/Y checkpoints" summary
- Validation test suite with >90% coverage of validation.py
- Compatibility tests verify version 0.x and 1.0 handling
- All tests pass
</success_criteria>

<output>
After completion, create `.planning/phases/03-checkpoint-robustness/03-03-SUMMARY.md`
</output>