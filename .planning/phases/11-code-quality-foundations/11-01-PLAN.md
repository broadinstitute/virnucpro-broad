---
phase: 11-code-quality-foundations
plan: 01
type: tdd
wave: 1
depends_on: []
files_modified:
  - virnucpro/core/env_config.py
  - tests/unit/test_env_config.py
autonomous: true

must_haves:
  truths:
    - "EnvConfig dataclass loads all VIRNUCPRO_* environment variables from os.environ"
    - "Invalid boolean env var values raise ValueError with descriptive message"
    - "get_env_config() returns cached singleton instance via @lru_cache"
    - "Tests can clear cache via get_env_config.cache_clear() for isolation"
  artifacts:
    - path: "virnucpro/core/env_config.py"
      provides: "Centralized environment variable access"
      contains: "class EnvConfig"
    - path: "tests/unit/test_env_config.py"
      provides: "Unit tests for EnvConfig"
      contains: "test_"
  key_links:
    - from: "virnucpro/core/env_config.py"
      to: "os.environ"
      via: "__post_init__ loading"
      pattern: "os\\.environ\\.get"
---

<objective>
Create `virnucpro/core/env_config.py` with a flat dataclass that centralizes all environment variable access.

Purpose: Foundation for QUAL-01. All scattered `os.getenv()` / `os.environ.get()` calls (19 sites across 9 files) will eventually route through this single dataclass. This plan creates the dataclass and tests it; migration of call sites happens in Plan 05.

Output: Working `EnvConfig` dataclass with `get_env_config()` factory, tested with TDD.
</objective>

<execution_context>
@/home/unix/carze/.claude/get-shit-done/workflows/execute-plan.md
@/home/unix/carze/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@virnucpro/pipeline/runtime_config.py (existing dataclass pattern to follow)
@virnucpro/utils/precision.py (existing env var boolean parsing)
</context>

<feature>
  <name>EnvConfig dataclass with cached factory</name>
  <files>virnucpro/core/env_config.py, tests/unit/test_env_config.py</files>
  <behavior>
    EnvConfig is a flat @dataclass that loads environment variables in __post_init__:

    Environment variables to centralize (from research scan of 19 call sites):
    - VIRNUCPRO_DISABLE_PACKING: bool (default False) — emergency packing rollback
    - VIRNUCPRO_DISABLE_FP16: bool (default False) — FP16 diagnostic rollback
    - VIRNUCPRO_V1_ATTENTION: bool (default False) — v1.0 attention compatibility
    - VIRNUCPRO_VIRAL_CHECKPOINT_MODE: bool (default False) — viral workload checkpoint tuning
    - VIRNUCPRO_DISABLE_COMPILE: bool (default False) — future torch.compile rollback (Phase 15)
    - CUDA_VISIBLE_DEVICES: Optional[str] (default None) — GPU visibility (read-only, not modified)
    - PYTORCH_CUDA_ALLOC_CONF: Optional[str] (default None) — CUDA allocator config (read-only)
    - TOKENIZERS_PARALLELISM: Optional[str] (default None) — tokenizer threading (read-only)

    Boolean parsing: accept ("1", "true", "yes") for True, ("0", "false", "no", "") for False.
    Invalid values (e.g., "banana"): raise ValueError with descriptive message.

    Factory: get_env_config() decorated with @lru_cache(maxsize=1) returns singleton.
    Tests clear cache via get_env_config.cache_clear().

    Test cases:
    - Default values when no env vars set -> all bools False, strings None
    - VIRNUCPRO_DISABLE_PACKING=true -> disable_packing == True
    - VIRNUCPRO_DISABLE_PACKING=1 -> disable_packing == True
    - VIRNUCPRO_DISABLE_PACKING=yes -> disable_packing == True
    - VIRNUCPRO_DISABLE_PACKING=false -> disable_packing == False
    - VIRNUCPRO_DISABLE_PACKING=0 -> disable_packing == False
    - VIRNUCPRO_DISABLE_PACKING=banana -> raises ValueError
    - VIRNUCPRO_DISABLE_FP16=TRUE (uppercase) -> disable_fp16 == True
    - get_env_config() returns same instance (cached)
    - get_env_config.cache_clear() allows new instance
  </behavior>
  <implementation>
    Follow the RuntimeConfig pattern in virnucpro/pipeline/runtime_config.py:
    - @dataclass with typed fields and defaults
    - __post_init__ for validation
    - Module-level logger

    Specific implementation:
    1. Define _parse_bool(value: str, var_name: str) -> bool helper
       - Accepts: "1", "true", "yes" (case-insensitive) -> True
       - Accepts: "0", "false", "no", "" -> False
       - Rejects everything else with ValueError including var_name in message
    2. @dataclass EnvConfig with fields matching env var names (snake_case)
    3. __post_init__ loads from os.environ.get() and parses via _parse_bool
    4. @lru_cache(maxsize=1) on get_env_config() factory function
    5. Module docstring with architecture notes explaining centralization purpose
  </implementation>
</feature>

<verification>
pytest tests/unit/test_env_config.py -v
</verification>

<success_criteria>
- EnvConfig loads all 8 environment variables
- Boolean parsing handles all valid values and rejects invalid ones with ValueError
- get_env_config() caching works correctly
- All tests pass
</success_criteria>

<output>
After completion, create `.planning/phases/11-code-quality-foundations/11-01-SUMMARY.md`
</output>
