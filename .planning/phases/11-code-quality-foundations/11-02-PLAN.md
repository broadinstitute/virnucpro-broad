---
phase: 11-code-quality-foundations
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - virnucpro/data/sequence_dataset.py
  - virnucpro/data/collators.py
  - tests/unit/test_collators.py
autonomous: true

must_haves:
  truths:
    - "CUDA isolation validation is defined once and used by both SequenceDataset and IndexBasedDataset"
    - "packed_queue in VarlenCollator uses collections.deque instead of list"
    - "All .pop(0) calls replaced with .popleft() for O(1) performance"
    - "All existing tests pass unchanged (1:1 behavior equivalence)"
  artifacts:
    - path: "virnucpro/data/sequence_dataset.py"
      provides: "Deduplicated CUDA validation via shared function"
      contains: "validate_cuda_isolation"
    - path: "virnucpro/data/collators.py"
      provides: "deque-based packed_queue"
      contains: "collections.deque"
  key_links:
    - from: "virnucpro/data/sequence_dataset.py"
      to: "validate_cuda_isolation"
      via: "function call in both dataset classes"
      pattern: "validate_cuda_isolation"
---

<objective>
Extract duplicate CUDA validation to a shared function and replace list-based queue operations with collections.deque.

Purpose: Addresses QUAL-02 (duplicate code extraction) and QUAL-05 (deque for O(1) popleft). The `_validate_cuda_isolation` method is duplicated identically in SequenceDataset (line 83) and IndexBasedDataset (line 245) of sequence_dataset.py. The `packed_queue` in collators.py uses list.pop(0) which is O(n).

Output: Deduplicated validation function, deque-based queue, all existing tests passing.
</objective>

<execution_context>
@/home/unix/carze/.claude/get-shit-done/workflows/execute-plan.md
@/home/unix/carze/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@virnucpro/data/sequence_dataset.py (duplicate _validate_cuda_isolation at lines 83 and 245)
@virnucpro/data/collators.py (packed_queue list with .pop(0) at lines 261, 285, 346)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Extract _validate_cuda_isolation to module-level function and deduplicate</name>
  <files>virnucpro/data/sequence_dataset.py</files>
  <action>
    Extract the duplicated `_validate_cuda_isolation` method to a module-level function `validate_cuda_isolation(validated_flag: bool) -> bool` at the top of sequence_dataset.py.

    The function should:
    1. Accept a `validated` boolean flag and return early if True (returns True)
    2. Get worker_info via `get_worker_info()`
    3. Only validate in worker processes (worker_info is not None)
    4. Check CUDA_VISIBLE_DEVICES is empty
    5. Check torch.cuda.is_available() returns False
    6. Return True on successful validation
    7. Log validation success with worker_id

    Then update both SequenceDataset._validate_cuda_isolation and IndexBasedDataset._validate_cuda_isolation to call the shared function:

    ```python
    def _validate_cuda_isolation(self):
        self._validated = validate_cuda_isolation(self._validated)
    ```

    Keep the method on each class (maintaining the same interface) but delegate to the shared function. This avoids changing any call sites.

    Important: Do NOT move the function to a separate module. Keep it in sequence_dataset.py to avoid import cycle risks and minimize the diff. The function is only used by these two classes in this same file.
  </action>
  <verify>
    pytest tests/unit/test_async_inference.py tests/unit/test_gpu_worker.py -v -x
    grep -n "validate_cuda_isolation" virnucpro/data/sequence_dataset.py
    # Should show: 1 module-level def, 2 class methods that delegate to it
  </verify>
  <done>
    _validate_cuda_isolation logic exists once as a module-level function. Both dataset classes delegate to it. No duplicate logic.
  </done>
</task>

<task type="auto">
  <name>Task 2: Replace packed_queue list with collections.deque in VarlenCollator</name>
  <files>virnucpro/data/collators.py</files>
  <action>
    Replace the `packed_queue` list with `collections.deque` in VarlenCollator:

    1. Add `from collections import deque` at top of file
    2. In `__init__`: change `self.packed_queue = []` to `self.packed_queue = deque()`
    3. Replace all `.pop(0)` calls with `.popleft()`:
       - Line 261: `batch_to_return = self.packed_queue.pop(0)` -> `batch_to_return = self.packed_queue.popleft()`
       - Line 285: `batch_to_return = self.packed_queue.pop(0)` -> `batch_to_return = self.packed_queue.popleft()`
       - Line 346: `batch = self.packed_queue.pop(0)` -> `batch = self.packed_queue.popleft()`
    4. Keep `.extend()` calls unchanged (deque supports .extend())
    5. Keep `len()` calls unchanged (deque supports len())
    6. Keep truthiness checks (`if self.packed_queue:`) unchanged (deque is truthy when non-empty)
    7. Also in gpu_worker.py line 349: `all_embeddings.insert(0, ...)` - this is a list with typically 0-few elements, NOT a queue pattern. Leave it as-is (insert(0) on a short list is fine).

    Note: Do NOT convert `self.buffer` to deque - it uses `.extend()` and list assignment (`self.buffer = []`) which are fine as list operations, and buffer is not used as a queue.

    After making the deque change, verify that existing collator tests cover these behavioral equivalence properties:
    - FIFO order maintained: items appended first are popleft'd first
    - Empty deque truthiness: `if self.packed_queue:` works the same as with list (both falsy when empty)
    - Mixed extend() + popleft(): extend adds multiple items, popleft removes from front in order

    These should already be covered by the existing collator test suite (the collator tests exercise the
    full pack-then-yield flow which exercises all three patterns). Verify by checking test output covers
    multi-batch scenarios where extend() adds batches and popleft() yields them in order. If any of
    these patterns are NOT covered by existing tests, add a targeted test case.
  </action>
  <verify>
    pytest tests/unit/test_collators.py -v -x
    grep -n "pop(0)" virnucpro/data/collators.py
    # Should show: no matches (all replaced with popleft)
    grep -n "deque" virnucpro/data/collators.py
    # Should show: import and initialization
    # Verify tests exercise extend+popleft flow (multi-batch packing scenarios)
    grep -n "packed_queue\|popleft\|extend\|batch.*return" tests/unit/test_collators.py
  </verify>
  <done>
    packed_queue uses collections.deque with O(1) popleft. No list.pop(0) calls remain in collators.py. All collator tests pass. FIFO order, empty truthiness, and mixed extend()+popleft() behaviors verified by test coverage.
  </done>
</task>

</tasks>

<verification>
pytest tests/unit/test_collators.py tests/unit/test_async_inference.py tests/unit/test_gpu_worker.py -v
# All existing tests pass with refactored code
grep -rn "\.pop(0)" virnucpro/data/collators.py
# No matches
</verification>

<success_criteria>
- CUDA isolation validation is defined once, used by both dataset classes
- packed_queue uses collections.deque with .popleft()
- No .pop(0) calls remain in collators.py
- All existing tests pass (1:1 behavior equivalence)
</success_criteria>

<output>
After completion, create `.planning/phases/11-code-quality-foundations/11-02-SUMMARY.md`
</output>
