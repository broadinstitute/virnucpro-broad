---
phase: 07-multi-gpu-coordination
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - virnucpro/data/shard_index.py
  - tests/unit/test_shard_index.py
autonomous: true
user_setup: []

must_haves:
  truths:
    - "Index file contains metadata for all sequences (id, length, file, offset)"
    - "Index is sorted by length descending for optimal packing"
    - "Index cache validates FASTA mtime for staleness detection"
    - "Stride distribution assigns indices [rank, rank+N, rank+2N...] to each worker"
  artifacts:
    - path: "virnucpro/data/shard_index.py"
      provides: "SequenceIndex class with create/load/shard methods"
      exports: ["SequenceIndex", "SequenceEntry", "create_sequence_index", "get_worker_indices"]
    - path: "tests/unit/test_shard_index.py"
      provides: "Unit tests for index creation and sharding"
      min_lines: 80
  key_links:
    - from: "create_sequence_index"
      to: "FASTA files"
      via: "Binary read with byte offset tracking"
      pattern: "open.*rb.*tell"
    - from: "get_worker_indices"
      to: "index.sequences"
      via: "Stride slicing [rank::world_size]"
      pattern: "range.*rank.*world_size"
---

<objective>
Create sequence index infrastructure for index-based sharding across GPUs.

Purpose: Enable deterministic, length-balanced work distribution by creating a metadata index of all sequences sorted by length descending. Workers take indices via stride distribution for balanced token load.

Output: SequenceIndex class with create, load, cache validation, and stride distribution methods.
</objective>

<execution_context>
@/home/unix/carze/.claude/get-shit-done/workflows/execute-plan.md
@/home/unix/carze/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/07-multi-gpu-coordination/07-CONTEXT.md
@.planning/phases/07-multi-gpu-coordination/07-RESEARCH.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create SequenceIndex class with index creation and caching</name>
  <files>virnucpro/data/shard_index.py</files>
  <action>
Create new module virnucpro/data/shard_index.py with:

1. SequenceEntry dataclass:
   - sequence_id: str
   - length: int
   - file_path: str
   - byte_offset: int (start position in FASTA file)

2. create_sequence_index(fasta_files: List[Path], index_path: Path) -> Path:
   - Check cache validity: index_path exists AND max(fasta_mtime) <= cached_mtime
   - If valid cache: log "Using cached index" and return index_path
   - Parse all FASTA files in binary mode (rb) tracking byte offsets:
     - For each '>' header line, save previous entry and record new byte_offset
     - Accumulate sequence length from non-header lines
   - Sort entries by length DESCENDING (critical for FFD packing efficiency)
   - Write JSON index with structure:
     ```json
     {
       "version": "1.0",
       "created": "ISO timestamp",
       "fasta_mtimes": {"file1.fa": mtime, ...},
       "total_sequences": N,
       "total_tokens": sum of lengths,
       "sequences": [SequenceEntry as dict, ...]
     }
     ```
   - Log: "Created index: {N} sequences, {total_tokens} total tokens"

3. get_worker_indices(index_path: Path, rank: int, world_size: int) -> List[int]:
   - Load index JSON
   - Return indices = list(range(rank, total_sequences, world_size))
   - Log distribution metrics: "Worker {rank}/{world_size}: {N} sequences, {tokens} tokens"

4. load_sequence_index(index_path: Path) -> Dict:
   - Load and return parsed index JSON
   - Used by IndexBasedDataset (Plan 02)

Use pathlib for paths, dataclasses for SequenceEntry, json for serialization.
  </action>
  <verify>
Module imports without error:
```
python -c "from virnucpro.data.shard_index import SequenceIndex, create_sequence_index, get_worker_indices"
```
  </verify>
  <done>
- create_sequence_index parses FASTA files and creates sorted JSON index
- Index includes byte_offset for each sequence entry
- get_worker_indices returns stride-distributed indices
- Cache validation uses FASTA mtime comparison
  </done>
</task>

<task type="auto">
  <name>Task 2: Add unit tests for index creation and sharding</name>
  <files>tests/unit/test_shard_index.py</files>
  <action>
Create tests/unit/test_shard_index.py with:

1. Test fixtures:
   - temp_fasta_file: Create temp FASTA with known sequences (5-10 seqs of varying lengths)
   - temp_index_path: Temp path for index file

2. TestSequenceIndex class:
   - test_create_index_from_fasta: Create index, verify sequence count, verify sorted by length desc
   - test_index_contains_byte_offsets: Verify each entry has valid byte_offset
   - test_index_cache_valid: Create index, call again, verify "Using cached" logged
   - test_index_cache_invalidated: Create index, touch FASTA (update mtime), recreate, verify rebuilt
   - test_total_tokens_correct: Sum of lengths matches total_tokens field

3. TestStrideDistribution class:
   - test_stride_distribution_world_size_4: For 100 sequences, 4 workers get 25 each via stride
   - test_stride_distribution_coverage: All indices covered exactly once across all workers
   - test_stride_distribution_balanced_tokens: Token distribution within 10% of mean across workers
   - test_worker_indices_deterministic: Same rank/world_size always returns same indices

4. TestEdgeCases class:
   - test_empty_fasta_file: Graceful handling of empty file
   - test_single_sequence: Index with single sequence works correctly
   - test_multi_file_index: Index across multiple FASTA files

Use pytest, tempfile for fixtures, pathlib for paths.
  </action>
  <verify>
```
pytest tests/unit/test_shard_index.py -v
```
All tests pass.
  </verify>
  <done>
- Index creation tests verify sorting, byte offsets, caching
- Stride distribution tests verify coverage and balance
- Edge cases handled
  </done>
</task>

</tasks>

<verification>
1. Run unit tests: `pytest tests/unit/test_shard_index.py -v`
2. Test with real FASTA (if available): Create index, verify sorted order, verify stride distribution
3. Verify JSON index is human-readable and contains expected structure
</verification>

<success_criteria>
- SequenceIndex creates sorted JSON index with byte offsets
- Cache validation detects stale index when FASTA modified
- Stride distribution gives deterministic, balanced assignment
- All unit tests pass
</success_criteria>

<output>
After completion, create `.planning/phases/07-multi-gpu-coordination/07-01-SUMMARY.md`
</output>
