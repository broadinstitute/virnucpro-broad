---
phase: 07-multi-gpu-coordination
plan: 02
type: execute
wave: 2
depends_on: ["07-01"]
files_modified:
  - virnucpro/data/sequence_dataset.py
  - tests/unit/test_sequence_dataset.py
autonomous: true
user_setup: []

must_haves:
  truths:
    - "IndexBasedDataset reads sequences by byte offset from index"
    - "Dataset yields sequences in index order (length-sorted for packing)"
    - "Dataset validates CUDA isolation in workers"
    - "Single-process mode works without worker sharding"
  artifacts:
    - path: "virnucpro/data/sequence_dataset.py"
      provides: "IndexBasedDataset class for index-based iteration"
      exports: ["IndexBasedDataset"]
    - path: "tests/unit/test_sequence_dataset.py"
      provides: "Unit tests for index-based dataset"
      min_lines: 60
  key_links:
    - from: "IndexBasedDataset.__iter__"
      to: "shard_index.load_sequence_index"
      via: "Index loading for sequence metadata"
      pattern: "load_sequence_index"
    - from: "IndexBasedDataset"
      to: "FASTA files"
      via: "Byte offset seeking"
      pattern: "seek.*byte_offset"
---

<objective>
Add IndexBasedDataset that reads sequences by byte offset from the sequence index.

Purpose: Workers iterate over pre-assigned indices (from stride distribution), seeking directly to byte offsets for efficient I/O. This replaces file-level iteration with index-based iteration for balanced work distribution.

Output: IndexBasedDataset class that works with existing VarlenCollator and AsyncInferenceRunner.
</objective>

<execution_context>
@/home/unix/carze/.claude/get-shit-done/workflows/execute-plan.md
@/home/unix/carze/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/07-multi-gpu-coordination/07-CONTEXT.md
@virnucpro/data/sequence_dataset.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add IndexBasedDataset to sequence_dataset.py</name>
  <files>virnucpro/data/sequence_dataset.py</files>
  <action>
Add new class to existing virnucpro/data/sequence_dataset.py (after SequenceDataset):

1. IndexBasedDataset(IterableDataset):
   - __init__(self, index_path: Path, indices: List[int], max_length: int = 1024):
     - Store index_path, indices list, max_length
     - Load index metadata: load_sequence_index(index_path)
     - Build sequence lookup: self._entries = index['sequences']
     - self._validated = False (for CUDA isolation check)

   - __iter__(self) -> Iterator[Dict[str, str]]:
     - Call self._validate_cuda_isolation() (reuse from SequenceDataset)
     - Group indices by file_path for efficient file access
     - For each file group:
       - Open file in binary mode
       - For each index in group:
         - entry = self._entries[idx]
         - Seek to byte_offset
         - Read and parse sequence (read lines until next '>' or EOF)
         - Truncate to max_length
         - Yield {'id': entry['sequence_id'], 'sequence': seq_str, 'file': filename}

   - __len__(self):
     - Return len(self.indices) (allows DataLoader to estimate total)

2. Helper method _read_sequence_at_offset(self, file_handle, entry) -> str:
   - Seek to entry['byte_offset']
   - Skip header line (starts with '>')
   - Read sequence lines until next '>' or EOF
   - Join and strip whitespace
   - Return sequence string

3. Update module imports to include:
   - from virnucpro.data.shard_index import load_sequence_index

4. Preserve existing SequenceDataset class (keep backward compatibility).

IMPORTANT: The _validate_cuda_isolation method already exists in SequenceDataset.
Either:
- Extract to module-level function and call from both classes, OR
- Copy the method to IndexBasedDataset (acceptable duplication for now)
  </action>
  <verify>
```
python -c "from virnucpro.data.sequence_dataset import IndexBasedDataset; print('OK')"
```
  </verify>
  <done>
- IndexBasedDataset reads sequences by byte offset
- Sequences yielded in index order (length-sorted)
- CUDA isolation validated in workers
- __len__ available for DataLoader
  </done>
</task>

<task type="auto">
  <name>Task 2: Add unit tests for IndexBasedDataset</name>
  <files>tests/unit/test_sequence_dataset.py</files>
  <action>
Create or extend tests/unit/test_sequence_dataset.py:

1. Test fixtures:
   - temp_fasta_with_index: Create temp FASTA, create index via create_sequence_index
   - Return (fasta_path, index_path, expected_sequences)

2. TestIndexBasedDataset class:
   - test_dataset_yields_all_sequences: Iterate dataset with all indices, verify all sequences returned
   - test_dataset_yields_in_index_order: Verify sequences returned in index order (length-sorted)
   - test_dataset_subset_indices: Pass subset of indices, verify only those sequences returned
   - test_dataset_byte_offset_seek: Verify sequences read correctly via byte offset (content matches)
   - test_dataset_max_length_truncation: Long sequence truncated to max_length
   - test_dataset_single_process: Works without worker sharding (worker_info is None)

3. TestDatasetIntegration class:
   - test_dataset_with_dataloader: DataLoader iterates IndexBasedDataset correctly
   - test_dataset_with_collator: VarlenCollator processes IndexBasedDataset output

Use pytest, tempfile for fixtures. Mock CUDA validation for CPU-only testing.
  </action>
  <verify>
```
pytest tests/unit/test_sequence_dataset.py -v
```
All tests pass.
  </verify>
  <done>
- IndexBasedDataset unit tests cover iteration, ordering, subsetting
- Integration tests verify DataLoader and collator compatibility
- All tests pass
  </done>
</task>

</tasks>

<verification>
1. Run unit tests: `pytest tests/unit/test_sequence_dataset.py -v`
2. Verify IndexBasedDataset integrates with existing SequenceDataset module
3. Test with real FASTA and index (if available)
</verification>

<success_criteria>
- IndexBasedDataset reads sequences by byte offset from index
- Sequences yielded in length-sorted order (index order)
- Works with VarlenCollator and DataLoader
- All unit tests pass
</success_criteria>

<output>
After completion, create `.planning/phases/07-multi-gpu-coordination/07-02-SUMMARY.md`
</output>
