---
phase: 02.1-parallel-embedding-merge
plan: 03
type: execute
wave: 3
depends_on: [02.1-02]
files_modified:
  - tests/test_integration_parallel_merge.py
  - virnucpro/pipeline/parallel_merge.py
autonomous: true
user_setup: []

must_haves:
  truths:
    - "Parallel merge produces identical output to sequential merge"
    - "Performance scales linearly with CPU core count"
    - "Integration tests verify end-to-end merge functionality"
    - "Error cases handled gracefully with partial success"
  artifacts:
    - path: "tests/test_integration_parallel_merge.py"
      provides: "End-to-end integration tests for parallel merge"
      min_lines: 150
    - path: "virnucpro/pipeline/parallel_merge.py"
      provides: "Error handling improvements based on test findings"
      contains: "failed_pairs"
  key_links:
    - from: "test_integration_parallel_merge.py"
      to: "virnucpro CLI"
      via: "subprocess calls"
      pattern: "subprocess.run.*virnucpro predict"
    - from: "parallel_merge_features"
      to: "error handling"
      via: "return tuple"
      pattern: "return.*merged_files.*failed_pairs"
---

<objective>
Create comprehensive integration tests and performance validation for parallel embedding merge.

Purpose: Ensure parallel merge maintains correctness while delivering expected performance improvements.
Output: Integration tests validating functionality, performance tests confirming speedup, enhanced error handling.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02.1-parallel-embedding-merge/02.1-01-SUMMARY.md
@.planning/phases/02.1-parallel-embedding-merge/02.1-02-SUMMARY.md

# Reference test patterns
@tests/test_integration_dnabert_multi_gpu.py
@tests/test_parallel_translate.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create integration tests for parallel merge</name>
  <files>tests/test_integration_parallel_merge.py</files>
  <action>
    Create comprehensive integration tests following established patterns:

    1. Setup test class with fixtures:
       ```python
       class TestParallelMergeIntegration(unittest.TestCase):
           @classmethod
           def setUpClass(cls):
               # Create temp directory
               # Generate mock DNABERT and ESM feature files
               # Create matched pairs with known data
       ```

    2. Test correctness - parallel vs sequential comparison:
       ```python
       def test_parallel_merge_matches_sequential(self):
           # Run merge with --merge-threads 4
           # Run merge with --merge-threads 1 (sequential)
           # Load both outputs with torch.load()
           # Compare tensors with torch.allclose()
           # Assert identical sequence IDs and shapes
       ```

    3. Test performance improvement:
       ```python
       def test_parallel_merge_performance(self):
           # Create 20+ file pairs
           # Time sequential merge (--merge-threads 1)
           # Time parallel merge (--merge-threads 4)
           # Assert parallel is at least 2x faster
           # Log actual speedup ratio
       ```

    4. Test CLI integration via subprocess:
       ```python
       def test_cli_merge_threads_parameter(self):
           # Use subprocess.run() to call virnucpro predict
           # Pass --merge-threads 2
           # Verify runs without error
           # Check logs for "parallel merge with 2 workers"
       ```

    5. Test error handling:
       ```python
       def test_partial_failure_handling(self):
           # Create mismatched file pairs (different sequence IDs)
           # Run parallel merge
           # Verify some files succeed, some fail
           # Check failed_files.txt or error logs
       ```

    6. Test checkpoint/resume:
       ```python
       def test_merge_checkpoint_resume(self):
           # Run merge partially (interrupt after some files)
           # Run merge again
           # Verify skips already-merged files
           # Verify completes remaining files
       ```

    7. Test auto-detection:
       ```python
       def test_auto_worker_detection(self):
           # Run without --merge-threads
           # Verify uses cpu_count() workers
           # Check logs for auto-detection message
       ```

    Use subprocess for CLI tests (matching Phase 2 pattern from test_integration_dnabert_multi_gpu.py).
    Create actual .pt files with torch.save() for realistic testing.
  </action>
  <verify>python -m pytest tests/test_integration_parallel_merge.py::TestParallelMergeIntegration::test_parallel_merge_matches_sequential -xvs</verify>
  <done>Integration tests validate correctness and performance of parallel merge</done>
</task>

<task type="auto">
  <name>Task 2: Enhance error handling with partial failure support</name>
  <files>virnucpro/pipeline/parallel_merge.py</files>
  <action>
    Update parallel_merge functions to return success/failure information:

    1. Modify parallel_merge_features() to track failures:
       ```python
       def parallel_merge_features(...) -> Tuple[List[Path], List[Tuple[Path, Path, str]]]:
           merged_files = []
           failed_pairs = []

           with ctx.Pool(num_workers) as pool:
               results = pool.imap(merge_file_pair_worker, file_pairs, chunksize=1)

               for result, (nuc, pro, out) in zip(results, file_pairs):
                   if result is not None:
                       merged_files.append(result)
                   else:
                       failed_pairs.append((nuc, pro, f"Merge failed for {nuc.name}"))

           if failed_pairs:
               logger.warning(f"Failed to merge {len(failed_pairs)} file pairs")

           return merged_files, failed_pairs
       ```

    2. Update parallel_merge_with_progress() similarly:
       - Return (merged_files, failed_pairs) tuple
       - Update progress bar to show success/failure count
       - Log failures but continue processing

    3. Enhanced worker error reporting:
       ```python
       def merge_file_pair_worker(file_pair):
           try:
               # existing merge logic
           except FileNotFoundError as e:
               logger.error(f"File not found: {e}")
               return None
           except RuntimeError as e:  # Torch loading errors
               logger.error(f"Failed to load tensors: {e}")
               return None
           except Exception as e:
               logger.error(f"Unexpected error in merge: {e}")
               return None
       ```

    This matches GPU worker pattern from Phase 1/2 where failures are logged but pipeline continues.
  </action>
  <verify>grep -n "failed_pairs" virnucpro/pipeline/parallel_merge.py</verify>
  <done>parallel_merge returns (merged_files, failed_pairs) tuple with enhanced error handling</done>
</task>

<task type="auto">
  <name>Task 3: Performance profiling and optimization verification</name>
  <files>tests/test_integration_parallel_merge.py</files>
  <action>
    Add performance profiling tests to verify optimization benefits:

    1. Create performance benchmark:
       ```python
       def test_merge_scaling_analysis(self):
           """Test that merge performance scales with worker count"""
           file_counts = [10, 20, 40]
           worker_counts = [1, 2, 4, os.cpu_count()]

           results = {}
           for n_files in file_counts:
               # Create n_files pairs of mock features
               for n_workers in worker_counts:
                   start = time.time()
                   # Run merge with n_workers
                   elapsed = time.time() - start
                   results[(n_files, n_workers)] = elapsed

           # Analyze scaling
           # Expect near-linear speedup up to cpu_count
           # Log performance table
       ```

    2. Memory usage validation:
       ```python
       def test_memory_efficient_streaming(self):
           """Verify Pool.imap() doesn't load all results into memory"""
           # Create 100+ file pairs
           # Monitor memory during merge (if possible)
           # Verify memory stays reasonable
       ```

    3. Create test summary report:
       ```python
       def tearDownClass(cls):
           # Print performance summary
           # Show speedup ratios
           # Highlight any performance regressions
       ```

    This provides concrete evidence that parallel merge delivers expected benefits.
  </action>
  <verify>python -m pytest tests/test_integration_parallel_merge.py::TestParallelMergeIntegration::test_merge_scaling_analysis -xvs</verify>
  <done>Performance tests confirm linear scaling with CPU cores</done>
</task>

</tasks>

<verification>
# Integration tests pass
python -m pytest tests/test_integration_parallel_merge.py -xvs

# Performance improvement verified
python -m pytest tests/test_integration_parallel_merge.py::TestParallelMergeIntegration::test_parallel_merge_performance -xvs

# Error handling works
grep "failed_pairs" virnucpro/pipeline/parallel_merge.py

# CLI integration works
virnucpro predict --help | grep merge-threads
</verification>

<success_criteria>
- Integration tests confirm parallel merge correctness
- Performance tests show >= 2x speedup with 4 workers
- Error handling allows partial completion
- CLI parameter controls parallelism
- Checkpoint/resume capability verified
</success_criteria>

<output>
After completion, create `.planning/phases/02.1-parallel-embedding-merge/02.1-03-SUMMARY.md`
</output>