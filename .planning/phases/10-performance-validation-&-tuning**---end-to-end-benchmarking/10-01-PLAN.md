---
phase: 10-performance-validation-tuning
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - virnucpro/pipeline/prediction.py
  - virnucpro/pipeline/pipeline_telemetry.py
autonomous: true

must_haves:
  truths:
    - "Every pipeline stage (1-9) logs its wall-clock duration via virnucpro logging"
    - "Pipeline prints a final summary block with per-stage timing breakdown, total time, and key metrics"
    - "Telemetry is integrated into virnucpro logging - no separate JSON files"
  artifacts:
    - path: "virnucpro/pipeline/pipeline_telemetry.py"
      provides: "PipelineTelemetry class for per-stage timing and summary"
      exports: ["PipelineTelemetry"]
    - path: "virnucpro/pipeline/prediction.py"
      provides: "Instrumented pipeline with per-stage timing"
      contains: "telemetry.start_stage"
  key_links:
    - from: "virnucpro/pipeline/prediction.py"
      to: "virnucpro/pipeline/pipeline_telemetry.py"
      via: "PipelineTelemetry import and usage"
      pattern: "from virnucpro.pipeline.pipeline_telemetry import PipelineTelemetry"
---

<objective>
Instrument the full 9-stage prediction pipeline with per-stage wall-clock timing and a final summary block.

Purpose: Phase 10 requires per-stage timing breakdown (translation, DNABERT-S, ESM-2, prediction, etc.) and a final summary. Currently, only translation and ESM-2 have timing. All 9 stages need instrumentation, and a summary block must print after pipeline completion with total time, per-stage breakdown, throughput metrics, and key telemetry.

Output: PipelineTelemetry helper class + instrumented prediction.py that logs timing for every stage and prints a clear summary block.
</objective>

<execution_context>
@/home/unix/carze/.claude/get-shit-done/workflows/execute-plan.md
@/home/unix/carze/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@virnucpro/pipeline/prediction.py
@virnucpro/utils/gpu_monitor.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create PipelineTelemetry helper class</name>
  <files>virnucpro/pipeline/pipeline_telemetry.py</files>
  <action>
Create a lightweight PipelineTelemetry class that tracks per-stage timing and produces a summary. This class integrates with the existing virnucpro logging system (logger = logging.getLogger('virnucpro.pipeline.telemetry')) — no separate JSON files.

The class must support:

1. `start_stage(name: str)` — Records time.monotonic() for stage start, logs "=== Stage N: {name} ===" via logger.info
2. `end_stage(name: str, extra: Optional[Dict] = None)` — Records end time, computes elapsed, logs elapsed time and any extra metrics (e.g., sequences processed, files created). The extra dict may contain keys like 'sequences', 'files', 'tokens' for structured logging.
3. `log_summary()` — Prints a formatted summary block via logger.info with:
   - Total pipeline wall time (formatted as HH:MM:SS)
   - Per-stage timing breakdown (stage name, elapsed, % of total)
   - Top 3 stages by time (bottleneck identification)
   - Key metrics from extra dicts accumulated during stages (e.g., total sequences, total tokens)
   - v1.0 baseline comparison: accepts a `v1_baseline_seconds` parameter (default: None). When provided, computes and prints speedup ratio.

Internal state:
- `_stages: Dict[str, Dict]` mapping stage_name -> {'start': float, 'end': float, 'extra': Dict}
- `_pipeline_start: float` set on first start_stage() call
- `_pipeline_end: float` set on log_summary() call
- `_stage_order: List[str]` preserves insertion order for summary display

Module-level logger: `logger = logging.getLogger('virnucpro.pipeline.telemetry')`

The summary block format:
```
================================================================================
PIPELINE SUMMARY
================================================================================
Total wall time: HH:MM:SS (XXXX.Xs)
Stages:
  1. Sequence Chunking ............  XXs ( X.X%)
  2. Six-Frame Translation ........  XXs ( X.X%)
  ...
  9. Consensus Scoring ............  XXs ( X.X%)
Bottlenecks: ESM-2 (XX%), DNABERT-S (XX%), Translation (XX%)
Key metrics:
  Sequences processed: XXX,XXX
  v2.0 architecture: ESM-2 async DataLoader + FlashAttention
================================================================================
```

Do NOT create any JSON output files. All output goes through the logging system.
  </action>
  <verify>
`python -c "from virnucpro.pipeline.pipeline_telemetry import PipelineTelemetry; t = PipelineTelemetry(); print('Import OK')"` succeeds.
  </verify>
  <done>PipelineTelemetry class exists with start_stage, end_stage, log_summary methods. All output via logging, no JSON files.</done>
</task>

<task type="auto">
  <name>Task 2: Instrument prediction.py with per-stage timing</name>
  <files>virnucpro/pipeline/prediction.py</files>
  <action>
Modify run_prediction() to use PipelineTelemetry for all 9 stages:

1. At the top of run_prediction(), create a PipelineTelemetry instance:
   ```python
   from virnucpro.pipeline.pipeline_telemetry import PipelineTelemetry
   telemetry = PipelineTelemetry()
   ```

2. Wrap each stage with telemetry.start_stage() / telemetry.end_stage():

   Stage 1 (Chunking): Already has basic timing. Replace with:
   ```python
   telemetry.start_stage("Sequence Chunking")
   # ... existing chunking code ...
   telemetry.end_stage("Sequence Chunking", {'sequences': num_sequences})
   ```

   Stage 2 (Translation): Already has start_time/elapsed_time. Replace time.time() calls with telemetry:
   ```python
   telemetry.start_stage("Six-Frame Translation")
   # ... existing translation code (keep all parallel/sequential logic) ...
   telemetry.end_stage("Six-Frame Translation", {
       'sequences': sequences_processed,
       'sequences_with_orfs': sequences_with_orfs,
       'seq_per_sec': sequences_per_sec
   })
   ```
   KEEP the existing logger.info lines for seq/s — they provide real-time feedback. Telemetry is additive.

   Stage 3 (Nucleotide Splitting):
   ```python
   telemetry.start_stage("Nucleotide File Splitting")
   # ... existing code ...
   telemetry.end_stage("Nucleotide File Splitting", {'files': len(nucleotide_files)})
   ```

   Stage 4 (Protein Splitting):
   ```python
   telemetry.start_stage("Protein File Splitting")
   # ... existing code ...
   telemetry.end_stage("Protein File Splitting", {'files': len(protein_files)})
   ```

   Stage 5 (DNABERT-S):
   ```python
   telemetry.start_stage("DNABERT-S Feature Extraction")
   # ... existing code (all parallel/sequential/checkpoint logic stays) ...
   telemetry.end_stage("DNABERT-S Feature Extraction", {
       'files': len(nucleotide_feature_files)
   })
   ```

   Stage 6 (ESM-2):
   ```python
   telemetry.start_stage("ESM-2 Feature Extraction")
   # ... existing code (all v1/v2 routing logic stays) ...
   telemetry.end_stage("ESM-2 Feature Extraction", {
       'files': len(protein_feature_files),
       'architecture': 'v2.0' if use_v2_architecture else 'v1.0'
   })
   ```

   Stage 7 (Feature Merging):
   ```python
   telemetry.start_stage("Feature Merging")
   # ... existing code ...
   telemetry.end_stage("Feature Merging", {'files': len(merged_feature_files)})
   ```

   Stage 8 (Prediction):
   ```python
   telemetry.start_stage("Model Prediction")
   # ... existing code ...
   telemetry.end_stage("Model Prediction", {'predictions': len(predictions)})
   ```

   Stage 9 (Consensus):
   ```python
   telemetry.start_stage("Consensus Scoring")
   # ... existing code ...
   telemetry.end_stage("Consensus Scoring", {'consensus_sequences': len(consensus)})
   ```

3. Before the final return statement (before cleanup), call:
   ```python
   telemetry.log_summary()
   ```

4. Handle checkpoint resume: When stages are skipped due to checkpointing (the `else` branches that load from checkpoint), still call telemetry.start_stage/end_stage with a note that it was skipped:
   ```python
   telemetry.start_stage("Stage Name")
   telemetry.end_stage("Stage Name", {'skipped': True, 'reason': 'checkpoint'})
   ```
   This ensures the summary shows all 9 stages even when some are skipped.

IMPORTANT: Do NOT modify the actual logic of any stage. Do NOT change v1/v2 routing, checkpoint logic, error handling, or parallel processing. Only ADD telemetry instrumentation around existing code. Do NOT remove existing logger.info/logger.warning calls.

IMPORTANT: Do NOT create any JSON telemetry files. All telemetry goes through the logging system via logger.info.
  </action>
  <verify>
`python -c "from virnucpro.pipeline.prediction import run_prediction; print('Import OK')"` succeeds. Verify that PipelineTelemetry is imported and used. Run `pytest tests/ -v -m 'not slow and not gpu' -x --timeout=30 -q 2>&1 | tail -5` to ensure no import regressions.
  </verify>
  <done>All 9 pipeline stages wrapped with telemetry.start_stage/end_stage. Summary block logged at pipeline completion. No JSON files created. No existing logic modified.</done>
</task>

</tasks>

<verification>
1. `python -c "from virnucpro.pipeline.pipeline_telemetry import PipelineTelemetry"` imports without error
2. `python -c "from virnucpro.pipeline.prediction import run_prediction"` imports without error
3. PipelineTelemetry.log_summary() produces formatted summary via logging
4. No JSON telemetry files are created
5. Existing tests pass: `pytest tests/unit/ -v -m 'not slow and not gpu' --timeout=60 -q`
</verification>

<success_criteria>
- PipelineTelemetry class exists and integrates with virnucpro logging
- All 9 pipeline stages have start/end timing instrumentation
- Summary block prints per-stage timing breakdown after pipeline completion
- No separate JSON/telemetry files created
- No existing pipeline logic modified (telemetry is additive only)
</success_criteria>

<output>
After completion, create `.planning/phases/10-performance-validation-&-tuning**---end-to-end-benchmarking/10-01-SUMMARY.md`
</output>
