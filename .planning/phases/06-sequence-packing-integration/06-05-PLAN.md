---
phase: 06-sequence-packing-integration
plan: 05
type: execute
wave: 4
depends_on: ["06-04"]
files_modified:
  - tests/integration/test_packed_equivalence.py
  - virnucpro/data/packing.py
autonomous: true

must_haves:
  truths:
    - "Packed embeddings match unpacked baseline (cosine similarity >0.999)"
    - "99% of sequences pass strict threshold, 1% allowed in 0.995-0.999 range"
    - "Validation function available for production use"
  artifacts:
    - path: "tests/integration/test_packed_equivalence.py"
      provides: "Packed vs unpacked equivalence tests"
      min_lines: 100
    - path: "virnucpro/data/packing.py"
      provides: "validate_packed_equivalence function"
      exports: ["GreedyPacker", "validate_packed_equivalence"]
  key_links:
    - from: "tests/integration/test_packed_equivalence.py"
      to: "virnucpro/models/esm2_flash.py"
      via: "model.forward_packed call"
      pattern: "model\\.forward_packed"
---

<objective>
Implement packed vs unpacked equivalence validation

Purpose: PACK-04 requirement - verify packed embeddings match unpacked baseline with cosine similarity >0.999. This is the gold standard test for FlashAttention varlen correctness. If packed == unpacked, there's no cross-sequence contamination.

Output: Integration tests and validation function for packed equivalence
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/06-sequence-packing-integration/06-RESEARCH.md
@.planning/phases/06-sequence-packing-integration/06-CONTEXT.md
@.planning/phases/06-sequence-packing-integration/06-04-SUMMARY.md
@virnucpro/models/esm2_flash.py
@virnucpro/data/collators.py
@virnucpro/data/packing.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add validate_packed_equivalence function to packing.py</name>
  <files>virnucpro/data/packing.py</files>
  <action>
Add validation function to virnucpro/data/packing.py:

```python
def validate_packed_equivalence(
    model,
    batch_converter,
    sequences: List[Tuple[str, str]],
    device: torch.device,
    strict_threshold: float = 0.999,
    lenient_threshold: float = 0.995,
    lenient_fraction: float = 0.01,
) -> Tuple[bool, Dict[str, Any]]:
    """
    Validate packed embeddings match unpacked baseline.

    Args:
        model: ESM2WithFlashAttention model
        batch_converter: ESM alphabet batch converter
        sequences: List of (id, sequence) tuples
        device: CUDA device
        strict_threshold: Cosine similarity threshold for most sequences (0.999)
        lenient_threshold: Lower threshold allowed for small fraction (0.995)
        lenient_fraction: Fraction allowed below strict threshold (0.01 = 1%)

    Returns:
        Tuple of (passed: bool, details: dict)
        details contains:
            - per_sequence: Dict[seq_id, cosine_sim]
            - strict_pass_rate: float
            - min_similarity: float
            - max_similarity: float
            - failed_sequences: List[str] (IDs with sim < lenient_threshold)
    """
```

Implementation (from RESEARCH.md validation pattern):
1. Process each sequence individually (unpacked baseline)
2. Pack all sequences using VarlenCollator
3. Run model.forward_packed
4. Extract embeddings using cu_seqlens
5. Compare with F.cosine_similarity
6. Return pass/fail with detailed metrics
  </action>
  <verify>
python -c "from virnucpro.data.packing import validate_packed_equivalence; print('Validation function imported')"
  </verify>
  <done>
validate_packed_equivalence function exists with proper signature
  </done>
</task>

<task type="auto">
  <name>Task 2: Create integration test for packed equivalence</name>
  <files>tests/integration/test_packed_equivalence.py</files>
  <action>
Create tests/integration/test_packed_equivalence.py:

```python
"""Integration tests for packed vs unpacked embedding equivalence.

These tests require GPU and ESM-2 model. Skip if unavailable.
"""
import pytest
import torch

# Skip entire module if CUDA unavailable
pytestmark = pytest.mark.skipif(
    not torch.cuda.is_available(),
    reason="CUDA required for packed equivalence tests"
)


@pytest.fixture(scope="module")
def esm_model():
    """Load ESM-2 model once for all tests."""
    from virnucpro.models.esm2_flash import load_esm2_model
    model, batch_converter = load_esm2_model(
        model_name="esm2_t33_650M_UR50D",  # Smaller model for faster tests
        device="cuda:0"
    )
    return model, batch_converter


class TestPackedEquivalence:
    """Test packed vs unpacked embedding equivalence."""

    def test_short_sequences(self, esm_model):
        """Short sequences (<50 aa) should match exactly."""
        model, batch_converter = esm_model
        sequences = [
            ("short1", "MKTAYIAK"),
            ("short2", "VLSPADKTNV"),
            ("short3", "MVHLT"),
        ]
        from virnucpro.data.packing import validate_packed_equivalence
        passed, details = validate_packed_equivalence(
            model, batch_converter, sequences, torch.device("cuda:0")
        )
        assert passed, f"Failed: {details}"
        assert details["min_similarity"] > 0.999

    def test_medium_sequences(self, esm_model):
        """Medium sequences (50-200 aa) should match."""
        model, batch_converter = esm_model
        sequences = [
            ("medium1", "MKTAYIAK" * 10),  # 80 aa
            ("medium2", "VLSPADKTNV" * 15),  # 150 aa
        ]
        from virnucpro.data.packing import validate_packed_equivalence
        passed, details = validate_packed_equivalence(
            model, batch_converter, sequences, torch.device("cuda:0")
        )
        assert passed, f"Failed: {details}"

    def test_mixed_lengths(self, esm_model):
        """Mixed length sequences in same batch."""
        model, batch_converter = esm_model
        sequences = [
            ("tiny", "MKT"),
            ("small", "MKTAYIAK"),
            ("medium", "MKTAYIAK" * 20),
            ("large", "MKTAYIAK" * 50),
        ]
        from virnucpro.data.packing import validate_packed_equivalence
        passed, details = validate_packed_equivalence(
            model, batch_converter, sequences, torch.device("cuda:0")
        )
        assert passed, f"Failed: {details}"


class TestCrossContamination:
    """Test that sequences don't contaminate each other."""

    def test_distinct_sequences_remain_distinct(self, esm_model):
        """Very different sequences should produce different embeddings."""
        model, batch_converter = esm_model
        # Hydrophobic vs charged sequences
        sequences = [
            ("hydrophobic", "AILVFMWP" * 5),
            ("charged", "DERKH" * 8),
        ]
        from virnucpro.data.packing import validate_packed_equivalence
        passed, details = validate_packed_equivalence(
            model, batch_converter, sequences, torch.device("cuda:0")
        )
        assert passed, f"Cross-contamination suspected: {details}"
```
  </action>
  <verify>
pytest tests/integration/test_packed_equivalence.py --collect-only 2>/dev/null | grep "test_" | head -5 || echo "Tests defined"
  </verify>
  <done>
Integration tests for packed vs unpacked equivalence
  </done>
</task>

<task type="auto">
  <name>Task 3: Update packing.py exports</name>
  <files>virnucpro/data/__init__.py</files>
  <action>
Add validate_packed_equivalence to virnucpro/data/__init__.py exports:

1. Update import: `from virnucpro.data.packing import GreedyPacker, validate_packed_equivalence`
2. Add to __all__ if it exists
  </action>
  <verify>
python -c "from virnucpro.data import validate_packed_equivalence; print('Validation function exported')"
  </verify>
  <done>
validate_packed_equivalence exportable from virnucpro.data
  </done>
</task>

</tasks>

<verification>
- [ ] validate_packed_equivalence function in packing.py
- [ ] Function returns (passed, details) tuple
- [ ] Strict threshold 0.999, lenient 0.995 with 1% allowance
- [ ] Integration tests cover short, medium, mixed length sequences
- [ ] Cross-contamination test verifies distinct sequences remain distinct
- [ ] All exports work from virnucpro.data
</verification>

<success_criteria>
1. Validation function compares packed vs unpacked embeddings
2. Returns detailed metrics (per-sequence similarity, pass rate, min/max)
3. Integration tests verify equivalence on GPU
4. Threshold system allows small FP16 precision variations
</success_criteria>

<output>
After completion, create `.planning/phases/06-sequence-packing-integration/06-05-SUMMARY.md`
</output>
